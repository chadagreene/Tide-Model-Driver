
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>tmd_predict documentation</title><meta name="generator" content="MATLAB 9.10"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2022-06-22"><meta name="DC.source" content="tmd_predict_documentation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1><tt>tmd_predict</tt> documentation</h1><!--introduction--><p><tt>tmd_predict</tt> constructs tidal predictions from the complex constituent coefficients in consolidated NetCDF tide model files.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Syntax</a></li><li><a href="#2">Description</a></li><li><a href="#3">Example: Tide gauge time series</a></li><li><a href="#6">Example: Map of tidal amplitude and currents</a></li><li><a href="#8">Example: NaNs near the coast</a></li><li><a href="#11">Example: Ice shelf flexure</a></li><li><a href="#14">Example: Drift track</a></li><li><a href="#16">Example: Time series of maps</a></li><li><a href="#21">Author Info</a></li></ul></div><h2 id="1">Syntax</h2><pre>z = tmd_predict(filename,lat,lon,time)
z = tmd_predict(filename,lat,lon,time,ptype)
z = tmd_predict(filename,lat,lon,time,ptype,'constituents',conList)
z = tmd_predict(...,,'coasts',MaskingMethod)
z = tmd_predict(...,'InferMinor',true_or_false)</pre><h2 id="2">Description</h2><p><tt>z = tmd_predict(filename,lat,lon,time)</tt> predicts tide heights at the specified <tt>lat,lon</tt> and <tt>time</tt>, using the TMD3.0 compatible consolidated NetCDF tide model data file. Location(s) <tt>lat,lon</tt> are decimal degrees, and can be scalars, vectors, or MxN arrays. Input <tt>time</tt> can be datetime or MATLAB's datenum format, and must be a scalar or a 1D vector.</p><p><tt>z = tmd_predict(filename,lat,lon,time,ptype)</tt> specifies a solution type. If <tt>ptype</tt> is not specified, <tt>'h'</tt> is the assumed <tt>ptype</tt>. Note the <tt>ptype</tt> is case sensitive! Options for <tt>ptype</tt> are:</p><div><ul><li><tt>'h'</tt> tidal height (m) (default)</li><li><tt>'u'</tt> zonal current velocity, positive pointing east (m/s)</li><li><tt>'v'</tt> meridional current velocity, positive pointing north (m/s)</li><li><tt>'U'</tt> zonal transport (m^2/s)</li><li><tt>'V'</tt> meridional height (m^2/s)</li></ul></div><p><tt>z = tmd_predict(filename,lat,lon,time,ptype,'constituents',conList)</tt> specifies tidal constituents as a cell array (e.g, <tt>{'m2','s2'}</tt>). If constituents are not specified, all constituents from the model are used.</p><p><tt>z = tmd_predict(...,,'coasts',MaskingMethod)</tt> specifies how coastal regions are masked. Can be <tt>NaN</tt>, <tt>'flexure'</tt>, or <tt>'unmask'</tt>. By default, <tt>MaskingMethod</tt> is <tt>NaN</tt>, meaning outputs are set to <tt>NaN</tt> wherever a nearest-neighbor interpolation of the ocean indicates land. The <tt>'flexure'</tt> option scales tidal constituents by a predicted coefficient of tidal deflection for ice shelf grounding zones (for CATS only). A third option, <tt>'unmask'</tt>, does not apply any masking, which may be preferred close to coasts, where, for example, a tide gauge may exist between land and ocean grid cells.</p><p><tt>z = tmd_predict(...,'InferMinor',true_or_false)</tt> specifies whether minor constituents should be inferred (<tt>true</tt> or <tt>false</tt>). By default, minor constituents are inferred unless constituents are specified.</p><h2 id="3">Example: Tide gauge time series</h2><p>This example uses data from a tide gauge near Nuuk, Greenland. The example data is in the <tt>doc/example_data</tt> folder of this toolbox.</p><p>Start by loading the tide gauge data, then predict tides at that location using the 15 constituent global `TPXO9_atlas_v5` model and the 8 constituent `Gr1kmTM` regional model.</p><pre class="codeinput"><span class="comment">% Load tide gauge data:</span>
fn = <span class="string">'h820_nuuk.nc'</span>;
lat = ncread(fn,<span class="string">'lat'</span>);
lon = ncread(fn,<span class="string">'lon'</span>);
t = ncread(fn,<span class="string">'time'</span>)+datenum(1800,1,1,0,0,0); <span class="comment">% units = 'days since 1800-01-01 00:00:00'</span>
sl = ncread(fn,<span class="string">'sea_level'</span>)/1000;

<span class="comment">% Predict tides at the tide gauge location:</span>
sl_tpxo9 = tmd_predict(<span class="string">'TPXO9_atlas_v5.nc'</span>,lat,lon,t,<span class="string">'h'</span>);
sl_Gr1km = tmd_predict(<span class="string">'Gr1kmTM_v1.nc'</span>,lat,lon,t,<span class="string">'h'</span>);

<span class="comment">% Plot observed and predicted tides:</span>
figure
plot(t,sl-mean(sl,<span class="string">'omitnan'</span>),<span class="string">'k'</span>,<span class="string">'linewidth'</span>,2)
hold <span class="string">on</span>
plot(t,sl_tpxo9,<span class="string">'linewidth'</span>,1)
plot(t,sl_Gr1km,<span class="string">'linewidth'</span>,1)
ylabel <span class="string">'tide height (m)'</span>
legend(<span class="string">'observations'</span>,<span class="string">'TPXO9_atlas_v5'</span>,<span class="string">'Gr1kmTm'</span>,<span class="string">'interpreter'</span>,<span class="string">'none'</span>)
xlim([datenum(<span class="string">'mar 26, 2017'</span>) datenum(<span class="string">'april 3, 2017'</span>)])
datetick(<span class="string">'x'</span>,<span class="string">'keeplimits'</span>)
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_01.png" alt=""> <p>In the figure above, we see that both the global and regional models match the observations pretty well, but neither is perfect. One way to assess tide model performance is to measure the distribution of the residuals after detiding an observation dataset. Here's what that might look like:</p><pre class="codeinput"><span class="comment">% Residuals of raw data, detided w/tpxo0, &amp; detided w/Gr1km:</span>
std([sl sl-sl_tpxo9 sl-sl_Gr1km],<span class="string">'omitnan'</span>)
</pre><pre class="codeoutput">ans =
    1.0836    0.1747    0.1927
</pre><p>The numbers above show that the raw data have a standard deviation of about 1.08 m. The 0.17 m standard deviation of residuals after detiding with TPXO9 suggests that TPXO9 does a slightly better job of capturing tidal variability here than Gr1kmTM, which has a 0.19 m distribution of residuals after detiding. In reality, a tide gauge captures dynamic ocean topography, variations in atmospheric pressure, and other phenomena that are not directly related to tidal variability, so the presence of residuals should not indicate failure of a model. It is possible that Gr1kmTM is as good or better than TPXO9 at this particular location, but further analysis is beyond the scope of this function reference page.</p><h2 id="6">Example: Map of tidal amplitude and currents</h2><p>Here's a map of tidal amplitudes at 12:30 in the afternoon on March 29, 2017. Note that TPXO9_atlas_v5 is a high resolution dataset with 15 constituents, so it may take a few seconds to predict a dense grid covering a large area. The Z prediction takes about 5 seconds on my laptop from 2019.</p><p>Below, we also use <a href="tmd_interp_documentation.html"><tt>tmd_interp</tt></a> to get the model's water column thicknes for context, and we plot 500 m wct contours as thin gray lines.</p><p>The <tt>cmocean</tt> colormap function is part of the Climate Data Toolbox for MATLAB and is also available as a standalone function from the MathWorks File Exchange.</p><pre class="codeinput"><span class="comment">% Define a time:</span>
t = datetime(<span class="string">'march 29, 2017 12:30'</span>);

<span class="comment">% A grid of lat,lon locations:</span>
lon = -85:0.025:-40;
lat = 85:-0.025:50;
[Lon,Lat] = meshgrid(lon,lat);

<span class="comment">% Predict tidal heights at time t (may take a few seconds):</span>
Z = tmd_predict(<span class="string">'TPXO9_atlas_v5.nc'</span>,Lat,Lon,t);

<span class="comment">% Get water column thickness:</span>
wct = tmd_interp(<span class="string">'TPXO9_atlas_v5.nc'</span>,<span class="string">'wct'</span>,Lat,Lon);

<span class="comment">% Make a map:</span>
figure
h = imagesc(lon,lat,Z);
h.AlphaData = isfinite(Z); <span class="comment">% makes nans transparent</span>
set(gca,<span class="string">'color'</span>,.4*[1 1 1]) <span class="comment">% makes transparent areas gray</span>
axis <span class="string">xy</span> <span class="string">image</span>
hold <span class="string">on</span>
[~,hC] = contour(lon,lat,wct,500:500:5000);
hC.Color = 0.5*[1 1 1]; <span class="comment">% gray contour lines</span>
hC.LineWidth = 0.3; <span class="comment">% thin contour lines</span>
caxis([-6 6]) <span class="comment">% color axis limits</span>
cb = colorbar;
ylabel(cb,<span class="string">'tide height (m)'</span>)
xlabel <span class="string">longitude</span>
ylabel <span class="string">latitude</span>
title(datestr(t))
cmocean <span class="string">balance</span> <span class="comment">% optional colormap</span>
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_02.png" alt=""> <p>Now add tidal currents. Again, it will take about 5 seconds for each component. Below, I'm using Climate Data Toolbox functions <tt>quiversc</tt> and <tt>earthimage</tt>. The <tt>quiversc</tt> function is convenient because it performs anti-aliased downsampling of the dense u,v grid.</p><pre class="codeinput"><span class="comment">% Calculate zonal and meridional components of tidal currents:</span>
u = tmd_predict(<span class="string">'TPXO9_atlas_v5.nc'</span>,Lat,Lon,t,<span class="string">'u'</span>);
v = tmd_predict(<span class="string">'TPXO9_atlas_v5.nc'</span>,Lat,Lon,t,<span class="string">'v'</span>);

<span class="comment">% Add u and v to the previous map:</span>
ax = axis;
q = quiversc(Lon,Lat,u,v,<span class="string">'density'</span>,100,<span class="string">'k'</span>);
q.AutoScaleFactor = 20;
axis(ax) <span class="comment">% resets limits after quiver might've adjusted them</span>
he = earthimage; <span class="comment">% optional, part of Climate Data Toolbox</span>
uistack(he,<span class="string">'bottom'</span>) <span class="comment">% places earth image under ocean data.</span>
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_03.png" alt=""> <h2 id="8">Example: NaNs near the coast</h2><p>In some cases, you may be interested in a tide gauge close to the coast that gets NaN'd out by default because it lies between land and ocean pixels. Consider this tide gauge near Syowa Station, Antarctica:</p><pre class="codeinput"><span class="comment">% Load example tide gauge data (found in the doc/example_data folder.)</span>
fn = <span class="string">'h127_syowa.nc'</span>;
lat = ncread(fn,<span class="string">'lat'</span>);
lon = ncread(fn,<span class="string">'lon'</span>);
t = ncdateread(fn,<span class="string">'time'</span>);
sl = ncread(fn,<span class="string">'sea_level'</span>)/1000;

figure
plot(t,sl,<span class="string">'k'</span>,<span class="string">'linewidth'</span>,1)
box <span class="string">off</span>
axis <span class="string">tight</span>
ylabel <span class="string">'tide gauge measurement (m)')</span>
title <span class="string">'Syowa station tide gauge'</span>
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_04.png" alt=""> <p>For 26 years, the tide gauge at Syowa station has logged hourly tides, with only a few interruptions. Clearly, tidal variability exists here, but what does the CATS model think?</p><pre class="codeinput"><span class="comment">% Predict tides at the location of interest:</span>
sl_cats = tmd_predict(<span class="string">'CATS2008_update_2022-06-11.nc'</span>,lat,lon,t,<span class="string">'h'</span>);

<span class="comment">% See how many tide predictions are finite:</span>
sum(isfinite(sl_cats))
</pre><pre class="codeoutput">ans =
     0
</pre><p>The Syowa tide gauge is closer to a land pixel than an ocean pixel in the CATS model, so it gets NaN'd out by default. To un-NaN the interpolation, choose the <tt>'unmask'</tt> option:</p><pre class="codeinput">sl_cats = tmd_predict(<span class="string">'CATS2008_update_2022-06-11.nc'</span>,lat,lon,t,<span class="string">'h'</span>,<span class="string">'coasts'</span>,<span class="string">'unmask'</span>);
sl_tpxo = tmd_predict(<span class="string">'TPXO9_atlas_v5.nc'</span>,lat,lon,t,<span class="string">'h'</span>,<span class="string">'coasts'</span>,<span class="string">'unmask'</span>);

<span class="comment">% Plot observations "detided" by each model:</span>
hold <span class="string">on</span>
plot(t,sl-sl_cats,<span class="string">'linewidth'</span>,1)
plot(t,sl-sl_tpxo,<span class="string">'linewidth'</span>,1)
xlim([datetime(<span class="string">'apr 9, 1998'</span>) datetime(<span class="string">'apr 21, 1998'</span>)]) <span class="comment">% zooms for clarity</span>
legend(<span class="string">'observations'</span>,<span class="string">'detided by cats'</span>,<span class="string">'detided by tpxo'</span>,<span class="string">'locaton'</span>,<span class="string">'best'</span>)
</pre><pre class="codeoutput">Warning: Ignoring extra legend entries. 
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_05.png" alt=""> <h2 id="11">Example: Ice shelf flexure</h2><p>This example assumes you have Antarctic Mapping Tools with the MODIS MOA and BedMachine plugins. Sorry about all of the dependencies, but I think it's important for context.</p><p>Start by defining a 500 m resolution grid around the grounding line of Rutford Ice Stream, Antarctica. Then calculate and display the estimated ice shelf flexure everywhere on the grid.</p><pre class="codeinput"><span class="comment">% Create a polar stereographic grid:</span>
res = 500; <span class="comment">% grid resolution in meters</span>
x = -1474594:res:-991780;
y = 521366:-res:-38552;
[X,Y] = meshgrid(x,y);
[Lat,Lon] = ps2ll(X,Y); <span class="comment">% ll2ps is an AMT function.</span>

<span class="comment">% Estimate ice shelf flexure at each point on the grid:</span>
flex = tmd_interp(<span class="string">'CATS2008_update_2022-06-11.nc'</span>,<span class="string">'flexure'</span>,Lat,Lon);

figure
h = imagesc(x,y,flex);
h.AlphaData = 0.8; <span class="comment">% transparency</span>
axis <span class="string">xy</span> <span class="string">image</span> <span class="string">off</span>
modismoaps(<span class="string">'contrast'</span>,<span class="string">'white'</span>)
cb = colorbar;
ylabel(cb,<span class="string">'ice shelf flexure coefficient'</span>)
bedmachine <span class="comment">% plots a gray grounding line</span>
scalebarps(<span class="string">'color'</span>,<span class="string">'w'</span>)
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_06.png" alt=""> <p>Let's imagine you collected laser altimetry by flying an airplane down the central trunk of Rutford Ice Stream. (For this example, we'll neglect the time it takes to fly the plane, and imagine you flew the whole flight path instantaneously).</p><p>Here's what your flight line looks like:</p><pre class="codeinput"><span class="comment">% Define a crude flowline:</span>
[xi,yi] = pspath([-1314322 -1181878 -1166297 -1231962],<span class="keyword">...</span>
                 [  130911   191012   300084   468143],<span class="keyword">...</span>
                 100,<span class="string">'method'</span>,<span class="string">'makima'</span>); <span class="comment">% 100 m spacing, makima interpolation</span>

<span class="comment">% Calculate the distance along the flowline in kilometers:</span>
di = pathdistps(xi,yi,<span class="string">'km'</span>);

hold <span class="string">on</span>
plot(xi,yi,<span class="string">'r'</span>,<span class="string">'linewidth'</span>,3)
text(xi(1),yi(1),<span class="string">'Flight path'</span>,<span class="string">'color'</span>,<span class="string">'r'</span>,<span class="string">'fontsize'</span>,14,<span class="string">'vert'</span>,<span class="string">'top'</span>)
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_07.png" alt=""> <p>Detiding your airborne laser altimetry along this flight line requires some knowledge of how much the ice surface should move as a result of tides. The default behavior of <tt>tmd_predict</tt> assumes the entire ice shelf is in total hydrostatic equilibrium and moves up and down with the total deflection of the tides, while grounded ice is NaN'd out. You can <tt>'unmask'</tt> the solution to get some information landward of the ocean pixels, or you can try to estimate ice <tt>'flexure'</tt> from a forward model.</p><p>Here's what the tidal solutions look like by default, unmasked, and accounting for ice shelf flexure:</p><pre class="codeinput"><span class="comment">% Convert to geo coordinates:</span>
[lati,loni] = ps2ll(xi,yi);

<span class="comment">% Time of high tide at Rutford Ice Stream:</span>
t = datenum(<span class="string">'22-Jan-2000 03:28:00'</span>);

<span class="comment">% Predict tides along the flight path at time t:</span>
fn = <span class="string">'CATS2008_update_2022-06-11.nc'</span>;
z_default = tmd_predict(fn,lati,loni,t,<span class="string">'h'</span>);
z_unmask = tmd_predict(fn,lati,loni,t,<span class="string">'h'</span>,<span class="string">'coasts'</span>,<span class="string">'unmask'</span>);
z_flexure = tmd_predict(fn,lati,loni,t,<span class="string">'h'</span>,<span class="string">'coasts'</span>,<span class="string">'flexure'</span>);

figure
subplot(2,1,1)
plot(di,z_default,<span class="string">'k'</span>,<span class="string">'linewidth'</span>,4)
hold <span class="string">on</span>
plot(di,z_unmask,<span class="string">'linewidth'</span>,2)
plot(di,z_flexure,<span class="string">'linewidth'</span>,2)
box <span class="string">off</span>
axis <span class="string">tight</span>
legend(<span class="string">'NaN (default)'</span>,<span class="string">'unmask'</span>,<span class="string">'flexure'</span>,<span class="string">'location'</span>,<span class="string">'best'</span>)
ylabel <span class="string">'tidal deflection (m)'</span>

<span class="comment">% Plot bedmachine profile for context:</span>
subplot(2,1,2)
bedmachine_profile(lati,loni,<span class="string">'horiz'</span>,di)
axis <span class="string">tight</span>
xlabel <span class="string">'distance along profile (km)'</span>
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_08.png" alt=""> <h2 id="14">Example: Drift track</h2><p>We've all been there. You've gassed up your dinghy, and you're about to run some illegal substances from Miami Beach to Red Bay, Bahamas. You know the trip will take 24 hours, but you're not sure what kind of tides you'll experience along the way. Well, there's nothing to worry about, because we have TMD!</p><pre class="codeinput"><span class="comment">% 24 hours of data at 1 minute resolution:</span>
t = datetime(<span class="string">'may 27, 2022 6:00'</span>):minutes(1):datetime(<span class="string">'may 28, 2022 6:00'</span>);

<span class="comment">% GPS locations along the way from Miami to Bahamas:</span>
lat = linspace(25.8063895,25.1288549,length(t));
lon = linspace(-80.1228916,-78.2059635,length(t));

<span class="comment">% Predict tides along the drift track:</span>
z = tmd_predict(<span class="string">'TPXO9_atlas_v5.nc'</span>,lat,lon,t,<span class="string">'z'</span>,<span class="string">'coasts'</span>,<span class="string">'unmask'</span>);

figure
geoscatter(lat,lon,20,z,<span class="string">'filled'</span>)
geolimits([24.5 26.5],[-81 -77.5])
geobasemap <span class="string">streets</span>
caxis([-1 1]*.35)
cmocean <span class="string">balance</span>
cb = colorbar;
ylabel(cb,<span class="string">'tide height (m)'</span>)
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_09.png" alt=""> <p>The blue on each end of the trip means you'll depart and arrive at low-ish tide, and the two red sections means you'll experience two high tides along the way.</p><h2 id="16">Example: Time series of maps</h2><p>If you give <tt>tmd_predict</tt> an MxN array of geographic points along with a 1D vector of times, the function will return a cube of tide solutions whose dimensions correspond to the dimensions of the geographic grid and the number of timesteps.</p><p><b>Be careful:</b> Depending on the number of grid points and the number of timesteps, the cubes created by <tt>tmd_predict</tt> can easily become huge and/or take a long time to solve. Here we predict for 25 hourly solutions for the Arctic Ocean.</p><p>For this example, we're creating a grid in equally spaced polar stereographic meters and then we convert the grid points to geographic coordinates. You can just as easily solve in equally-spaced geo points, but for this particular application, polar stereographic makes more sense, because every grid cell will end up being the same size. Below I'm using the <a href="https://github.com/chadagreene/arctic-mapping-tools">Arctic Mapping Tools'</a> <tt>psn2ll</tt> to convert the ps meters to lat,lon coordinates:</p><pre class="codeinput"><span class="comment">% Create a grid</span>
x = (-2700:5:3600)*1000;
y = (2000:-5:-4000)*1000;
[X,Y] = meshgrid(x,y);
[Lat,Lon] = psn2ll(X,Y);

t = datenum(<span class="string">'march 29, 2017'</span>):1/24:datenum(<span class="string">'march 30, 2017'</span>);
Z = tmd_predict(<span class="string">'Arc2kmTM_v1.nc'</span>,Lat,Lon,t);
</pre><img vspace="5" hspace="5" src="tmd_predict_documentation_10.png" alt=""> <p>If you're following along, you probably noticed it took a minute to churn through all 25 hourly solutions for a grid this size. That is expected, so again, be mindful that solving a long time series with short timesteps and a big grid will probably take a while to solve.</p><p>Here's a look at the data we just created:</p><pre class="codeinput">whos <span class="string">Lat</span> <span class="string">Lon</span> <span class="string">Z</span> <span class="string">t</span>
</pre><pre class="codeoutput">  Name         Size                     Bytes  Class     Attributes

  Lat       1201x1261                12115688  double              
  Lon       1201x1261                12115688  double              
  Z         1201x1261x25            302892200  double              
  t            1x25                       200  double              

</pre><p>Above, you see that <tt>Lat</tt> and <tt>Lon</tt> are both 1201x1261, <tt>t</tt> has 25 hourly timesteps, and <tt>Z</tt>'s dimensions are then 1201x1261x25.</p><p>Here's what the data looks like when we animate it. Below, I'm using the <tt>cmocean</tt> and <tt>gif</tt> functions from the <a href="https://github.com/chadagreene/CDT">Climate Data Toolbox for MATLAB</a>.</p><pre>% Get water column thickness for visual context:
wct = tmd_interp('Arc2kmTM_v1.nc','wct',Lat,Lon);</pre><pre>figure
h = imagesc(x,y,Z(:,:,1));
h.AlphaData = wct&gt;0; % makes land transparent
hold on
axis xy tight
[~,hC] = contourpsn(Lat,Lon,wct,0:500:7000);
hC.LineWidth = 0.25;
hC.Color = .5*[1 1 1];
caxis([-1 1]*5)
cmocean bal
set(gca,'color',[.01 .21 0],... % makes land dark green
   'xtick',[],'ytick',[],...  % removes tick labels
   'position',[0 0 1 1]); % fills the entire figure
txt = text(.5,1,datestr(t(1),'mmm dd, yyyy HH:MM:SS'),...
   'units','normalized','vert','top','horiz','center',...
   'fontweight','bold','fontsize',16,'backgroundcolor','w');</pre><pre>gif('html/arctic_tides.gif','delaytime',1/10)
for k = 2:25
   h.CData = Z(:,:,k);
   txt.String = datestr(t(k),'mmm dd, yyyy HH:MM:SS');
   gif
end</pre><p><img vspace="5" hspace="5" src="arctic_tides.gif" alt=""> </p><h2 id="21">Author Info</h2><p>The <tt>tmd_predict</tt> function and its documentation were written by Chad A. Greene, June 2022.</p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2021a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% |tmd_predict| documentation
% |tmd_predict| constructs tidal predictions from the complex constituent 
% coefficients in consolidated NetCDF tide model files. 
% 
%% Syntax 
% 
%  z = tmd_predict(filename,lat,lon,time)
%  z = tmd_predict(filename,lat,lon,time,ptype)
%  z = tmd_predict(filename,lat,lon,time,ptype,'constituents',conList)
%  z = tmd_predict(...,,'coasts',MaskingMethod)
%  z = tmd_predict(...,'InferMinor',true_or_false)
% 
%% Description 
% 
% |z = tmd_predict(filename,lat,lon,time)| predicts tide heights at the
% specified |lat,lon| and |time|, using the TMD3.0 compatible consolidated
% NetCDF tide model data file. Location(s) |lat,lon| are decimal degrees, and
% can be scalars, vectors, or MxN arrays. Input |time| can be datetime or
% MATLAB's datenum format, and must be a scalar or a 1D vector. 
%
% |z = tmd_predict(filename,lat,lon,time,ptype)| specifies a solution type.
% If |ptype| is not specified, |'h'| is the assumed |ptype|. Note the |ptype| is
% case sensitive! Options for |ptype| are: 
%
% * |'h'| tidal height (m) (default)
% * |'u'| zonal current velocity, positive pointing east (m/s) 
% * |'v'| meridional current velocity, positive pointing north (m/s) 
% * |'U'| zonal transport (m^2/s) 
% * |'V'| meridional height (m^2/s) 
%  
% |z = tmd_predict(filename,lat,lon,time,ptype,'constituents',conList)| 
% specifies tidal constituents as a cell array (e.g, |{'m2','s2'}|). If 
% constituents are not specified, all constituents from the model are used. 
% 
% |z = tmd_predict(...,,'coasts',MaskingMethod)| specifies how coastal regions are masked. 
% Can be |NaN|, |'flexure'|, or |'unmask'|. By default, |MaskingMethod| is |NaN|, meaning outputs 
% are set to |NaN| wherever a nearest-neighbor interpolation of the ocean indicates land. 
% The |'flexure'| option scales tidal constituents by a predicted coefficient of tidal 
% deflection for ice shelf grounding zones (for CATS only). A third option, |'unmask'|, does not apply 
% any masking, which may be preferred close to coasts, where, for example, a tide gauge 
% may exist between land and ocean grid cells. 
% 
% |z = tmd_predict(...,'InferMinor',true_or_false)| specifies whether minor
% constituents should be inferred (|true| or |false|). By default, minor constituents are
% inferred unless constituents are specified. 
% 
%% Example: Tide gauge time series  
% This example uses data from a tide gauge near Nuuk, Greenland. The
% example data is in the |doc/example_data| folder of this toolbox. 
% 
% Start by loading the tide gauge data, then predict tides at that location
% using the 15 constituent global `TPXO9_atlas_v5` model and the 8
% constituent `Gr1kmTM` regional model.  

% Load tide gauge data: 
fn = 'h820_nuuk.nc';
lat = ncread(fn,'lat');
lon = ncread(fn,'lon');
t = ncread(fn,'time')+datenum(1800,1,1,0,0,0); % units = 'days since 1800-01-01 00:00:00' 
sl = ncread(fn,'sea_level')/1000; 

% Predict tides at the tide gauge location: 
sl_tpxo9 = tmd_predict('TPXO9_atlas_v5.nc',lat,lon,t,'h');
sl_Gr1km = tmd_predict('Gr1kmTM_v1.nc',lat,lon,t,'h');

% Plot observed and predicted tides: 
figure
plot(t,sl-mean(sl,'omitnan'),'k','linewidth',2)
hold on
plot(t,sl_tpxo9,'linewidth',1)
plot(t,sl_Gr1km,'linewidth',1)
ylabel 'tide height (m)'
legend('observations','TPXO9_atlas_v5','Gr1kmTm','interpreter','none')
xlim([datenum('mar 26, 2017') datenum('april 3, 2017')])
datetick('x','keeplimits')

%%
% In the figure above, we see that both the global and regional models match 
% the observations pretty well, but neither is perfect. One way to assess 
% tide model performance is to measure the distribution of the residuals 
% after detiding an observation dataset. Here's what that might look like: 

% Residuals of raw data, detided w/tpxo0, & detided w/Gr1km:
std([sl sl-sl_tpxo9 sl-sl_Gr1km],'omitnan')

%% 
% The numbers above show that the raw data have a standard deviation of
% about 1.08 m. The 0.17 m standard deviation of residuals after detiding
% with TPXO9 suggests that TPXO9 does a slightly better job of capturing
% tidal variability here than Gr1kmTM, which has a 0.19 m distribution of 
% residuals after detiding. In reality, a tide gauge captures dynamic ocean 
% topography, variations in atmospheric pressure, and other phenomena that are 
% not directly related to tidal variability, so the presence of residuals should 
% not indicate failure of a model. It is possible that Gr1kmTM is as good or
% better than TPXO9 at this particular location, but further analysis is
% beyond the scope of this function reference page. 

%% Example: Map of tidal amplitude and currents
% Here's a map of tidal amplitudes at 12:30 in the afternoon on March 29,
% 2017. Note that TPXO9_atlas_v5 is a high resolution dataset with 15
% constituents, so it may take a few seconds to predict a dense grid
% covering a large area. The Z prediction takes about 5 seconds on my laptop 
% from 2019. 
% 
% Below, we also use <tmd_interp_documentation.html |tmd_interp|> to get the 
% model's water column thicknes for context, and we plot 500 m wct contours
% as thin gray lines.  
% 
% The |cmocean| colormap function is part of the Climate Data Toolbox for
% MATLAB and is also available as a standalone function from the MathWorks
% File Exchange. 

% Define a time:
t = datetime('march 29, 2017 12:30');

% A grid of lat,lon locations: 
lon = -85:0.025:-40; 
lat = 85:-0.025:50; 
[Lon,Lat] = meshgrid(lon,lat); 

% Predict tidal heights at time t (may take a few seconds): 
Z = tmd_predict('TPXO9_atlas_v5.nc',Lat,Lon,t); 

% Get water column thickness: 
wct = tmd_interp('TPXO9_atlas_v5.nc','wct',Lat,Lon);

% Make a map: 
figure
h = imagesc(lon,lat,Z);
h.AlphaData = isfinite(Z); % makes nans transparent
set(gca,'color',.4*[1 1 1]) % makes transparent areas gray
axis xy image 
hold on
[~,hC] = contour(lon,lat,wct,500:500:5000);
hC.Color = 0.5*[1 1 1]; % gray contour lines 
hC.LineWidth = 0.3; % thin contour lines
caxis([-6 6]) % color axis limits 
cb = colorbar; 
ylabel(cb,'tide height (m)') 
xlabel longitude
ylabel latitude 
title(datestr(t))
cmocean balance % optional colormap

%%
% Now add tidal currents. Again, it will take about 5 seconds for each
% component. Below, I'm using Climate Data Toolbox functions |quiversc| and
% |earthimage|. The |quiversc| function is convenient because it performs 
% anti-aliased downsampling of the dense u,v grid. 

% Calculate zonal and meridional components of tidal currents: 
u = tmd_predict('TPXO9_atlas_v5.nc',Lat,Lon,t,'u'); 
v = tmd_predict('TPXO9_atlas_v5.nc',Lat,Lon,t,'v'); 

% Add u and v to the previous map: 
ax = axis; 
q = quiversc(Lon,Lat,u,v,'density',100,'k'); 
q.AutoScaleFactor = 20; 
axis(ax) % resets limits after quiver might've adjusted them
he = earthimage; % optional, part of Climate Data Toolbox
uistack(he,'bottom') % places earth image under ocean data. 

%% Example: NaNs near the coast 
% In some cases, you may be interested in a tide gauge close to the coast
% that gets NaN'd out by default because it lies between land and ocean
% pixels. Consider this tide gauge near Syowa Station, Antarctica: 

% Load example tide gauge data (found in the doc/example_data folder.)
fn = 'h127_syowa.nc'; 
lat = ncread(fn,'lat');
lon = ncread(fn,'lon');
t = ncdateread(fn,'time');
sl = ncread(fn,'sea_level')/1000; 

figure
plot(t,sl,'k','linewidth',1)
box off
axis tight
ylabel 'tide gauge measurement (m)')
title 'Syowa station tide gauge'

%% 
% For 26 years, the tide gauge at Syowa station has logged hourly tides,
% with only a few interruptions. Clearly, tidal variability exists here, but
% what does the CATS model think? 

% Predict tides at the location of interest: 
sl_cats = tmd_predict('CATS2008_update_2022-06-11.nc',lat,lon,t,'h');

% See how many tide predictions are finite: 
sum(isfinite(sl_cats))

%% 
% The Syowa tide gauge is closer to a land pixel than an ocean pixel in 
% the CATS model, so it gets NaN'd out by default. To un-NaN the
% interpolation, choose the |'unmask'| option: 

sl_cats = tmd_predict('CATS2008_update_2022-06-11.nc',lat,lon,t,'h','coasts','unmask');
sl_tpxo = tmd_predict('TPXO9_atlas_v5.nc',lat,lon,t,'h','coasts','unmask');

% Plot observations "detided" by each model: 
hold on
plot(t,sl-sl_cats,'linewidth',1)
plot(t,sl-sl_tpxo,'linewidth',1)
xlim([datetime('apr 9, 1998') datetime('apr 21, 1998')]) % zooms for clarity
legend('observations','detided by cats','detided by tpxo','locaton','best')

%% Example: Ice shelf flexure 
% This example assumes you have Antarctic Mapping Tools with the MODIS MOA
% and BedMachine plugins. Sorry about all of the dependencies, but I think
% it's important for context. 
% 
% Start by defining a 500 m resolution grid around the grounding line of
% Rutford Ice Stream, Antarctica. Then calculate and display the estimated
% ice shelf flexure everywhere on the grid. 

% Create a polar stereographic grid: 
res = 500; % grid resolution in meters
x = -1474594:res:-991780;
y = 521366:-res:-38552;
[X,Y] = meshgrid(x,y); 
[Lat,Lon] = ps2ll(X,Y); % ll2ps is an AMT function.

% Estimate ice shelf flexure at each point on the grid: 
flex = tmd_interp('CATS2008_update_2022-06-11.nc','flexure',Lat,Lon); 

figure
h = imagesc(x,y,flex); 
h.AlphaData = 0.8; % transparency
axis xy image off
modismoaps('contrast','white')
cb = colorbar; 
ylabel(cb,'ice shelf flexure coefficient')
bedmachine % plots a gray grounding line 
scalebarps('color','w')

%%
% Let's imagine you collected laser altimetry by flying an airplane down
% the central trunk of Rutford Ice Stream. (For this example, we'll neglect
% the time it takes to fly the plane, and imagine you flew the whole flight
% path instantaneously). 
% 
% Here's what your flight line looks like: 

% Define a crude flowline: 
[xi,yi] = pspath([-1314322 -1181878 -1166297 -1231962],...
                 [  130911   191012   300084   468143],...
                 100,'method','makima'); % 100 m spacing, makima interpolation 

% Calculate the distance along the flowline in kilometers: 
di = pathdistps(xi,yi,'km'); 

hold on
plot(xi,yi,'r','linewidth',3)
text(xi(1),yi(1),'Flight path','color','r','fontsize',14,'vert','top')

%% 
% Detiding your airborne laser altimetry along this flight line requires
% some knowledge of how much the ice surface should move as a result of
% tides. The default behavior of |tmd_predict| assumes the entire ice shelf
% is in total hydrostatic equilibrium and moves up and down with the total
% deflection of the tides, while grounded ice is NaN'd out. You can
% |'unmask'| the solution to get some information landward of the ocean
% pixels, or you can try to estimate ice |'flexure'| from a forward model. 
%
% Here's what the tidal solutions look like by default, unmasked, and
% accounting for ice shelf flexure: 

% Convert to geo coordinates: 
[lati,loni] = ps2ll(xi,yi); 

% Time of high tide at Rutford Ice Stream: 
t = datenum('22-Jan-2000 03:28:00');

% Predict tides along the flight path at time t: 
fn = 'CATS2008_update_2022-06-11.nc';
z_default = tmd_predict(fn,lati,loni,t,'h'); 
z_unmask = tmd_predict(fn,lati,loni,t,'h','coasts','unmask'); 
z_flexure = tmd_predict(fn,lati,loni,t,'h','coasts','flexure'); 

figure
subplot(2,1,1) 
plot(di,z_default,'k','linewidth',4)
hold on
plot(di,z_unmask,'linewidth',2)
plot(di,z_flexure,'linewidth',2)
box off
axis tight
legend('NaN (default)','unmask','flexure','location','best')
ylabel 'tidal deflection (m)'

% Plot bedmachine profile for context: 
subplot(2,1,2) 
bedmachine_profile(lati,loni,'horiz',di)
axis tight
xlabel 'distance along profile (km)'

%% Example: Drift track 
% We've all been there. You've gassed up your dinghy, and you're about to
% run some illegal substances from Miami Beach to Red Bay, Bahamas. You know 
% the trip will take 24 hours, but you're not sure what kind of tides
% you'll experience along the way. Well, there's nothing to worry about,
% because we have TMD! 

% 24 hours of data at 1 minute resolution: 
t = datetime('may 27, 2022 6:00'):minutes(1):datetime('may 28, 2022 6:00'); 

% GPS locations along the way from Miami to Bahamas: 
lat = linspace(25.8063895,25.1288549,length(t)); 
lon = linspace(-80.1228916,-78.2059635,length(t)); 

% Predict tides along the drift track: 
z = tmd_predict('TPXO9_atlas_v5.nc',lat,lon,t,'z','coasts','unmask'); 

figure
geoscatter(lat,lon,20,z,'filled')
geolimits([24.5 26.5],[-81 -77.5])
geobasemap streets
caxis([-1 1]*.35)
cmocean balance 
cb = colorbar; 
ylabel(cb,'tide height (m)')

%%
% The blue on each end of the trip means you'll depart and arrive at
% low-ish tide, and the two red sections means you'll experience two high
% tides along the way. 

%% Example: Time series of maps 
% If you give |tmd_predict| an MxN array of geographic points along with a
% 1D vector of times, the function will return a cube of tide solutions
% whose dimensions correspond to the dimensions of the geographic grid and
% the number of timesteps. 
% 
% *Be careful:* Depending on the number of grid points and the number of
% timesteps, the cubes created by |tmd_predict| can easily become huge
% and/or take a long time to solve. Here we predict for 25 hourly solutions
% for the Arctic Ocean. 
%
% For this example, we're creating a grid in equally spaced
% polar stereographic meters and then we convert the grid points to geographic
% coordinates. You can just as easily solve in equally-spaced geo points,
% but for this particular application, polar stereographic makes more 
% sense, because every grid cell will end up being the same size.
% Below I'm using the <https://github.com/chadagreene/arctic-mapping-tools Arctic Mapping Tools'>
% |psn2ll| to convert the ps meters to lat,lon coordinates: 

% Create a grid
x = (-2700:5:3600)*1000;
y = (2000:-5:-4000)*1000; 
[X,Y] = meshgrid(x,y); 
[Lat,Lon] = psn2ll(X,Y); 

t = datenum('march 29, 2017'):1/24:datenum('march 30, 2017'); 
Z = tmd_predict('Arc2kmTM_v1.nc',Lat,Lon,t); 

%%
% If you're following along, you probably noticed it took a minute to churn 
% through all 25 hourly solutions for a grid this size. That is expected,
% so again, be mindful that solving a long time series with short timesteps
% and a big grid will probably take a while to solve. 
% 
% Here's a look at the data we just created:

whos Lat Lon Z t

%%
% Above, you see that |Lat| and |Lon| are both 1201x1261, |t| has 25 hourly
% timesteps, and |Z|'s dimensions are then 1201x1261x25. 
% 
% Here's what the data looks like when we animate it. Below, I'm using the
% |cmocean| and |gif| functions from the <https://github.com/chadagreene/CDT Climate Data Toolbox for MATLAB>.

%%
%  % Get water column thickness for visual context: 
%  wct = tmd_interp('Arc2kmTM_v1.nc','wct',Lat,Lon); 
%  
%  figure
%  h = imagesc(x,y,Z(:,:,1));
%  h.AlphaData = wct>0; % makes land transparent
%  hold on
%  axis xy tight
%  [~,hC] = contourpsn(Lat,Lon,wct,0:500:7000); 
%  hC.LineWidth = 0.25; 
%  hC.Color = .5*[1 1 1]; 
%  caxis([-1 1]*5)
%  cmocean bal
%  set(gca,'color',[.01 .21 0],... % makes land dark green
%     'xtick',[],'ytick',[],...  % removes tick labels
%     'position',[0 0 1 1]); % fills the entire figure
%  txt = text(.5,1,datestr(t(1),'mmm dd, yyyy HH:MM:SS'),...
%     'units','normalized','vert','top','horiz','center',...
%     'fontweight','bold','fontsize',16,'backgroundcolor','w'); 
%  
%  gif('html/arctic_tides.gif','delaytime',1/10)
%  for k = 2:25
%     h.CData = Z(:,:,k); 
%     txt.String = datestr(t(k),'mmm dd, yyyy HH:MM:SS');
%     gif
%  end
%%
% <<arctic_tides.gif>>
%
%% Author Info 
% The |tmd_predict| function and its documentation were written by Chad A.
% Greene, June 2022. 

##### SOURCE END #####
--></body></html>